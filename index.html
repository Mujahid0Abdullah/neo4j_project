<html>

<head>
	<title>SAHABELER: Battles Sequence </title>
	<meta charset="UTF-8">
	<meta name="description" content="SAHABELER: Battles Sequence ">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../style.css" />
	<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
</head>

<body>
	<p>
		<select id="personsTitles" style="display: none;">
			<input type="range" style="display: inline-block; width: 300px;" id="scaleRange" min="300" max="15000"
				value="4400">

	</p>

	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://d3js.org/topojson.v2.min.js"></script>

	<script>

		var config = {
			"width": 1800,
			"height": 900,
			"margin": {
				"top": 20,
				"right": 40,
				"bottom": 30,
				"left": 40
			}
		}
		var scaleRangeInput = document.getElementById("scaleRange");
		var currentScaleValue = scaleRangeInput.value;
		scaleRangeInput.addEventListener("input", function () {
			var newScaleValue = scaleRangeInput.value;
			projection.scale(newScaleValue);
			// Update your map or visualization using the updated projection
		});
		var width = config.width,
			height = config.height;

		var oceanColor = '#f9f9f9',
			landColor = '#ddd',
			flyingArcColor = '#4f9954',
			flyingArcShadowColor = '#333',
			flyingArcShadowStrokeColor = '#ccc',
			cityMarkerColor = '#999',
			cityLabelColor = '#666',
			cityLabelShadowColor = '#eee';

		var flyingArcWidth = 2,
			flyingArcShadowWidth = 0.5,
			flyingArcShadowOpacity = 0.5,
			flyingArcShadowBlur = 5,
			cityMarkerRadius = 2,
			cityLabelFont = '12px "Montserrat", sans-serif',
			cityLabelTextAlign = 'center',
			cityLabelOffset = [0, -7],
			cityLabelShadowBlur = 5,
			loftedness = 1.3,
			// transitionDuration = 4000,
			transitionEase = d3.easeQuad;

		// TODO: These probably shouldn't be global
		var link,
			focalPoint,
			flyingArcLength;

		var canvas = d3.select('body').append('canvas')
			.attr('width', width + config.margin.left + config.margin.right)
			.attr('height', height + config.margin.top + config.margin.bottom);

		var context = canvas.node().getContext('2d');

		context.font = cityLabelFont;
		context.textAlign = cityLabelTextAlign;

		var projection = d3.geoOrthographic()
			.scale(currentScaleValue)
			.translate([width / 2, height / 2])
			.precision(0.1);
		/*
					var projection = d3.geoMercator()
					.scale(300)
					.translate([width / 2, height / 2]);*/

		var loftedProjection = d3.geoOrthographic()
			.scale(((height - 10) / 2) * loftedness)
			.translate([width / 2, height / 2])
			.precision(0.1);

		var path = d3.geoPath()
			.projection(projection)
			.context(context);

		var swoosh = d3.line()
			.curve(d3.curveNatural)
			.defined(function (d) { return projection.invert(d); })
			.context(context);

		var current = [0, 45];



		var draw = function () { }

		// to dedpulicate an array
		function onlyUnique(value, index, self) {
			return self.indexOf(value) === index;
		}

		d3.queue()
			.defer(d3.json, '../data/110m.json')
			.defer(d3.json, '../data/persons.json')
			.await(ready);

		function ready(error, world, e) {
			if (error) throw error;

			// build the array of season/persons and opening locations
			var personsData = e.persons,
				places = world.objects.places.geometries,
				locationsObject = {};

			// build the select
			personsData
				.filter(function (val) {
					return val.openingSequenceLocations.length > 0
				})
				.forEach(function (val, ind) {
					d3.select("#personsTitles")
						.append("option")
						.text(`${val.personTitle} (${val.seasonNum})`);
				})

			// select behavior
			d3.select("#personsTitles")
				.style("display", "block")
				.style("margin-top", config.margin.top)
				.on("change", function () {
					var personSelect = d3.select(this).property('value').split("(")[1].toLowerCase().replace(/([^A-Z0-9])/gi, "");
					console.log(personSelect)

					context.clearRect(0, 0, width, height);
					drawLine(locationsObject[personSelect], 0);
				})

			var sphere = { type: "Sphere" },
				land = topojson.feature(world, world.objects.land);

			// Add unique ID for each geo city
			places.forEach(function (d, i) {
				d.id = i;


			});

			personsData.forEach(function (val, ind) {
				var ids = [],
					coords = [],
					locations = [],
					featuresProp = [];

				val.openingSequenceLocations.forEach(function (v, i) {
					var index = places.findIndex(function (element) {
						console.log(element)

						return element.properties.name == v;
					});

					if (index !== -1) {
						var place = places[index];
						ids.push(place.id);
						coords.push(place.coordinatesGeo);
						locations.push(place);
						featuresProp.push({
							name: place.properties.name,
							id: place.id
						});
					} else {
						console.error('Place not found for name:', v);
						// Hatanın nasıl ele alınacağını belirleyin.
						// Örneğin, bir uyarı gösterebilir veya default bir değer ekleyebilirsiniz.
					}

				})

				var feature = {
					type: 'Feature',
					geometry: {
						type: "LineString",
						coordinates: coords
					},
					properties: featuresProp
				}
				locationsObject[val.seasonNum] = {
					ids: ids,
					locations: locations,
					feature: feature
				};
			})

			// build the visualization

			function draw(t, person) {
				context.clearRect(0, 0, width, height);

				// Rotate globe to focus on the flying arc
				focusGlobeOnPoint(focalPoint(t));

				// Oceans
				context.beginPath();
				path(sphere);
				context.fillStyle = oceanColor;
				context.fill();

				// Land
				context.beginPath();
				path(land);
				context.fillStyle = landColor;
				context.fill();

				// Flying arc
				context.beginPath();
				path(person.feature);
				//swoosh(flyingArc(person));
				context.setLineDash([t * flyingArcLength * 1.7, 1e6]);
				context.lineWidth = flyingArcWidth;
				context.strokeStyle = flyingArcColor;
				context.stroke();

				//Flying arc's shadow
				context.beginPath();
				path(person.feature);
				context.setLineDash([t * flyingArcLength * 1.6, 1e6]);
				context.globalAlpha = flyingArcShadowOpacity;
				context.shadowColor = flyingArcShadowColor;
				context.shadowBlur = flyingArcShadowBlur;
				context.lineWidth = flyingArcShadowWidth;
				context.strokeStyle = flyingArcShadowStrokeColor;
				context.stroke();
				context.shadowBlur = 0;
				context.globalAlpha = 1;

				// add markers and labels for all cities
				person.locations.forEach(function (d, i) {
					// City marker 
					var p = projection(d.coordinatesGeo),
						x = p[0],
						y = p[1];
					context.beginPath();
					context.arc(x, y, cityMarkerRadius, 0, 2 * Math.PI);
					context.fillStyle = cityMarkerColor;
					context.fill();

					// City label 
					var x = x + cityLabelOffset[0],
						y = y + cityLabelOffset[1];
					context.shadowBlur = cityLabelShadowBlur;
					context.shadowColor = cityLabelShadowColor;
					context.fillStyle = cityLabelColor;
					context.fillText(d.properties.name, x, y);
					context.shadowBlur = 0;
				})
			};

			function drawLine(person) {
				console.log("person")
				console.log(person)
				// haritanın animasyon sırasında ilk savaştan son savaşa doğru odaklanmasını sağlar.
				focalPoint = d3.geoInterpolate(person.locations[0].coordinatesGeo, person.locations[person.locations.length - 1].coordinatesGeo);
				//zamanı
				var transitionDuration = person.ids.length * 1000;

		
				flyingArcLength = lineLength(flyingArc(person));

				var timer = d3.timer(tick);

				function tick(elapsed) {
					// draw the link
					draw(transitionEase(elapsed / transitionDuration), person);

					if (elapsed / transitionDuration >= 1) {
						timer.stop();
						current = centerCoordinates(person);
					};
				}
			}
			// draw the first person
			drawLine(locationsObject['8147']);
		}

		function flyingArc(person) {
			var coordinates = person.feature.geometry.coordinates.map(function (val, ind) {
				return projection(val);
			});
			return coordinates;
		}

		function locationAlongArc(start, end, theta) {
			return d3.geoInterpolate(start, end)(theta);
		}

		function focusGlobeOnPoint(point) {
			var x = point[0],
				y = point[1],
				cx = x + 3,
				cy = y + 3,
				rotation = [-cx, -cy];
			projection.rotate(rotation);
			//loftedProjection.rotate(rotation);
		}

		function lineLength(points) {
			var d = 0;
			for (var i = 0; i < points.length - 1; i++) {
				var x0 = points[i][0],
					y0 = points[i][1],
					x1 = points[i + 1][0],
					y1 = points[i + 1][1],
					dx = x1 - x0,
					dy = y1 - y0;
				d += Math.sqrt(dx * dx + dy * dy);
			}
			return d;
		}

		function centerCoordinates(person) {
			var cx = 0,
				cy = 0,
				l = person.locations.length;
			// person.locations.forEach(function(d,i){
			// 	cx += d.coordinatesGeo[0];
			// 	cy += d.coordinatesGeo[1];
			// })
			// return [cx/l, cy/l];
			console.log(person)
			cx += person.locations[0].coordinatesGeo[0];
			cy += person.locations[0].coordinatesGeo[1];
			cx += person.locations[l - 1].coordinatesGeo[0];
			cy += person.locations[l - 1].coordinatesGeo[1];
			return [cx / 2, cy / 2];
		}



	</script>
</body>

</html>